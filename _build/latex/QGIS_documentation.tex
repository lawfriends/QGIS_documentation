%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage[,numfigreset=2,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{QGIS\_documentation Documentation}
\date{Jul 11, 2020}
\release{}
\author{Lorenzo Amici}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Title}
\label{\detokenize{index:title}}

\section{Subtitle}
\label{\detokenize{index:subtitle}}
\sphinxurl{https://docs.qgis.org/3.10/en/docs/index.html}

\sphinxhref{https://docs.qgis.org/3.10/en/docs/index.html}{QGIS}


\subsection{Sub subtitle}
\label{\detokenize{index:sub-subtitle}}
\sphinxguilabel{Processing Toolbox}

\sphinxcode{\sphinxupquote{excercise data}}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=200\sphinxpxdimen]{{1200px-QGIS_logo,_2017.svg}.png}\hspace*{\fill}}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{1200px-QGIS_logo,_2017.svg}.png}
\caption{QGIS logo}\label{\detokenize{index:id1}}\end{figure}


\sphinxstrong{See also:}


This is a simple \sphinxstylestrong{seealso} note \(\rightarrow\).



\begin{sphinxadmonition}{note}{Note:}
This is a \sphinxstylestrong{note} box.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
This is a \sphinxstyleemphasis{warning}.
\end{sphinxadmonition}


\subsubsection{Sub sub subtitle}
\label{\detokenize{index:sub-sub-subtitle}}

\paragraph{General Info}
\label{\detokenize{introduction/general:general-info}}\label{\detokenize{introduction/general::doc}}
The OSGeo UN Committee promotes the development and use of open source software that meets UN needs and supports the aims of the UN. Following a meeting between OSGeo Board of Directors and the UN GIS team at FOSS4G in Seoul, Korea in September 2015, the Committee has mainly worked on the UN Open GIS Initiative, a project “…to identify and develop an Open Source GIS bundle that meets the requirements of UN operations, taking full advantage of the expertise of mission partners including partner nations, technology contributing countries, international organisations, academia, NGOs, private sector. The strategic approach shall be developed with best and shared principles, standards and ownership in a prioritized manner that addresses capability gaps and needs without duplicating efforts of other Member States or entities. The UN Open GIS Initiative strategy shall collaboratively and cooperatively develop, validate, assess, migrate and implement sound technical capabilities with all the appropriate documentation and training that in the end provides a united effort to improve the effectiveness and efficiency of utilizing Open Source GIS around the world.”


\subparagraph{1. Purpose of this documentation}
\label{\detokenize{introduction/general:purpose-of-this-documentation}}
This educational material is designed as a step-by-step software learning guide for QGIS.


\paragraph{Preparation}
\label{\detokenize{preparation/preparation:preparation}}\label{\detokenize{preparation/preparation::doc}}
In this section we will show all the necessary setup steps in order to follow along the QGIS exercise.


\subparagraph{Install QGIS}
\label{\detokenize{preparation/preparation:install-qgis}}
Download QGIS 3.14 (Long Term Release) for Windows 64bit at \sphinxurl{https://qgis.org/downloads/QGIS-OSGeo4W-3.14.0-1-Setup-x86\_64.exe}.
Other versions are available in the \sphinxhref{https://qgis.org/en/site/forusers/download.html}{QGIS Download page}.

\begin{sphinxadmonition}{note}{Note:}
After downloading QGIS, you will have various option to launch the program, as you see in this image:

\noindent\sphinxincludegraphics[width=100\sphinxpxdimen]{{2.1_QGIS_programs}.png}

In order to complete this exercise be sure to launch the one with GRASS since we will need some
functionalities that are only available using the tools that GRASS offers.
\end{sphinxadmonition}


\subparagraph{Download the data}
\label{\detokenize{preparation/preparation:download-the-data}}

\subparagraph{Create a new project}
\label{\detokenize{preparation/preparation:create-a-new-project}}
Before starting with the analysis of the data, we have to set up a new Project. To do so, run QGIS with GRASS and click on \sphinxstyleemphasis{New Project}
(or press \sphinxcode{\sphinxupquote{Ctrl+N}}).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2.3_new_project}.PNG}
\caption{Create a new project}\label{\detokenize{preparation/preparation:id1}}\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} \begin{description}
\item[{\sphinxstylestrong{Import vector data}}] \leavevmode
To import vector data, go to \sphinxstyleemphasis{Layer-\textgreater{}Add layer-\textgreater{}Add vector layer} or use the Browser panel (usually placed above the Layer Panel on
the left side of the screen; if not, you can enable it by clicking \sphinxstyleemphasis{View-\textgreater{}Panels} and tick “Browser panel”). In the Browser, you can
search the data folder and simply drag and drop the files in the map.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{2.3.1_add_layer}.PNG}
\caption{Add a vector layer}\label{\detokenize{preparation/preparation:id2}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=250\sphinxpxdimen]{{2.3.1_browser_panel}.PNG}
\caption{The Browser panel}\label{\detokenize{preparation/preparation:id3}}\end{figure}

For this excercise, we will use the following layers:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{buildings\_a.shp}}

\item {} 
\sphinxcode{\sphinxupquote{landuse\_a.shp}}

\item {} 
\sphinxcode{\sphinxupquote{natural.shp}}

\item {} 
\sphinxcode{\sphinxupquote{places.shp}}

\item {} 
\sphinxcode{\sphinxupquote{pofw\_a.shp}}

\item {} 
\sphinxcode{\sphinxupquote{pois\_a.shp}}

\item {} 
\sphinxcode{\sphinxupquote{roads.shp}}

\item {} 
\sphinxcode{\sphinxupquote{water\_a.shp}}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{Import raster data}}] \leavevmode
To import raster data, you can go to \sphinxstyleemphasis{Layer-\textgreater{}Add layer-\textgreater{}Add raster layer} or drag and drop them from the Browser panel.
For this exercise, you can add the following data:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Seoul\_DTM.tif}}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{Layers panel}}] \leavevmode
The Layers panel is a useful way to keep track of all the layers currently loaded in our Project. It’s usually placed
below the Browser panel, but if you don’t have it activated you can do so by clicking on \sphinxstyleemphasis{View-\textgreater{}Panels} and tick “Layers”.

Once you add all the data it should look like this:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{2.3.4_layers_panel}.PNG}
\caption{The Layers panel}\label{\detokenize{preparation/preparation:id4}}\end{figure}

The Layers panel can also be used to choose which layers we want to see in our map: just by unticking a layer we hide it from our map.
Also, we can choose the order of the layers, because layers can overlap and hide portions of each other, so it’s important to decide
which one is visualized on top of the others. To do so, you can select the layer you want to change and use the arrow symbols,
or simply drag the layer in the position you want it to be.

\end{description}

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
If the Project CRS (that can be seen in the bottom right corner of the window) is not specified, when importing the first layer QGIS
will set the Project CRS to the CRS of that first layer. From then onwards, QGIS automatically reprojects any imported layer in the
projection of the Project but only for visualization, the data remain in the original projection.
\end{sphinxadmonition}

Once all the data are added, the map should look like this:

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{2.3.4_all_data}.PNG}

We can now save our project (\sphinxstyleemphasis{Project-\textgreater{}Save} or \sphinxcode{\sphinxupquote{Ctrl+s}}) so that you will have all the added layers and progress always available by just
opening the saved project. Remember to do this from time to time during the exercise.

\begin{sphinxadmonition}{note}{Note:}
When saving a project, QGIS creates a \sphinxcode{\sphinxupquote{.qgz}} file, that represents the saved project. Note that this file does not contain directly all
the added layers, but it records the path necessary to reach each one of the layers, enabling QGIS to include them when opening the saved project.
\end{sphinxadmonition}


\subparagraph{Manipulate CRS of the project and the data}
\label{\detokenize{preparation/preparation:manipulate-crs-of-the-project-and-the-data}}
The data we use in our geo-analyses often come from different sources, and therefore also have a different Coordinate Reference System (CRS).
In order to homogenize the works and assure that all the tools work correctly, it is recommended to reproject all the data in the same CRS.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} \begin{description}
\item[{\sphinxstylestrong{Reprojecting vector layers}}] \leavevmode
This tool is available at \sphinxstyleemphasis{Vector-\textgreater{}Data management tools-\textgreater{}Reproject layer}. It provides a function that reprojects a vector layer, creating a new
layer with the same features as the input one, but with geometries reprojected to a new CRS.
The required input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the vector layer to be reprojected (in the example \sphinxstyleemphasis{buildings\_a})

\item {} 
\sphinxstyleemphasis{Target CRS}: the target Coordinate Reference System. You can choose from the
recent ones in the dropdown menu or click the icon to choose between all the available ones. Our choice will be
\sphinxguilabel{EPSG:32652 - WGS 84 / UTM zone 52N}

\item {} 
\sphinxstyleemphasis{Reprojected}: the path and the name of the output raster layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{2.4.1_reproject_layer}.PNG}
\caption{Reproject layer function window}\label{\detokenize{preparation/preparation:id5}}\end{figure}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{Reprojecting raster layers}}] \leavevmode
Available at \sphinxstyleemphasis{Raster-\textgreater{}Projections-\textgreater{}Warp (reproject)}, it provides a function that reprojects a raster layer. The tool requires as input:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the raster layer to be reprojected (in the example the \sphinxstyleemphasis{Seoul\_DTM})

\item {} 
\sphinxstyleemphasis{Target CRS}: the target Coordinate Reference System. You can choose from the recent ones in the dropdown menu or click the icon to choose between
all the available ones. Our choice will be \sphinxguilabel{EPSG:32652 - WGS 84 / UTM zone 52N}

\item {} 
\sphinxstyleemphasis{Resampling method to use}: the method to be used for resampling the data, we will use the \sphinxstyleemphasis{Nearest Neighbor}

\item {} 
\sphinxstyleemphasis{Reprojected}:  the path and the name of the output raster layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{2.4.2_reproject_raster}.PNG}
\caption{Reproject raster function window}\label{\detokenize{preparation/preparation:id6}}\end{figure}

\end{description}

\end{enumerate}

In order to continue with the tutorial please reproject all the imported vector and raster layers following the examples above.
Once all the layers are reprojected we need to check if the CRS of the project is the same as the data: to do so, click on the
CRS setting button

\noindent\sphinxincludegraphics{{2.4.2_reproject_map}.png}

in the bottom right of the window and select also here
\sphinxguilabel{EPSG:32652 - WGS 84 / UTM zone 52N}.

\begin{sphinxadmonition}{note}{Note:}
In this exercise we will refer to the new reprojected layers as \sphinxcode{\sphinxupquote{\sphinxstyleemphasis{originalname}\_rep}}.
You can create your new layers with the same name in order to be consistent with the naming.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
After reprojecting all the layers be sure to delete the original layers. You can do this
by simply selecting the layers you want to delete in the Layer panel and then click on the Remove layer/Group button.

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{2.4.2_remove_layers}.PNG}
\end{sphinxadmonition}


\subparagraph{Clip all the data to the study area}
\label{\detokenize{preparation/preparation:clip-all-the-data-to-the-study-area}}
Often the data provided is in a wider area than the one needed, so we can define an area of interest and clip all the layers to that same area;
in this way we shorten computational times and also provide consistency to the data.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{Create the working area}
\begin{quote}

We will create a vector polygon layer, in the shape of a rectangle, that will represent the area we are considering in this tutorial.
In order to do so:
\begin{itemize}
\item {} 
Create a vector layer using \sphinxstyleemphasis{Layer-\textgreater{}Create Layer-\textgreater{}New shapefile layer} or use the shortcut symbol \sphinxincludegraphics{{2.5.1_create_layer_button}.png}

\item {} 
Specify its characteristics as follows:
\begin{quote}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{File name}: \sphinxcode{\sphinxupquote{\sphinxstyleemphasis{path}/area\_of\_interest.shp}}

\item {} 
\sphinxstyleemphasis{File encoding}: System

\item {} 
\sphinxstyleemphasis{Geometry type}: Polygon

\item {} 
The CRS should be by default set to the one of the maps but check it to be \sphinxguilabel{EPSG:32652 - WGS 84 / UTM zone 52N}

\end{itemize}

\noindent\sphinxincludegraphics{{2.5.1_area_of_interest}.PNG}
\end{quote}

\item {} 
Click “Ok”

\end{itemize}

Once you created the layer, you need to add the polygon representing the working area:
\begin{quote}
\begin{itemize}
\item {} 
Right click on area\_of\_interest in the Layer panel and select “Toggle editing”

\item {} 
Right-click anywhere on the top toolbar (or go to \sphinxstyleemphasis{View-\textgreater{}Toolbars} and add it from there)
and enable the “Shape digitizing toolbar”. This way we can add a perfect rectangle polygon to our shapefile

\item {} 
Click on “Add rectangle from extent”

\end{itemize}

\noindent\sphinxincludegraphics{{2.5.1_add_rectangle}.PNG}
\begin{itemize}
\item {} 
Draw a rectangle in the area around Seoul by left-clicking to start drawing from an angle and then right-clicking
when the size is the desired one (not too big but big enough to contain some of the natural points, see the picture below)

\end{itemize}

\noindent\sphinxincludegraphics{{2.5.1_aoi}.PNG}
\begin{itemize}
\item {} 
Click on “Save layer edits” and toggle editing off

\end{itemize}
\end{quote}

Now that you have your working area layer we can clip all our layers to it.
\end{quote}

\item {} 
\sphinxstylestrong{Clipping vector layer}
\begin{quote}

Available at \sphinxstyleemphasis{Vector-\textgreater{}Geoprocessing tools-\textgreater{}Clip}. It provides an algorithm that clips a vector layer using the features of another polygon layer.
Only the parts of the features in the Input layer that fall within the polygons of the Overlay layer will be added to the resulting layer.
The attributes of the features are not modified, although properties such as area or length of the features will be modified by the clipping operation.
The input parameters are:
\begin{quote}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the vector layer to be clipped (in the example \sphinxcode{\sphinxupquote{landuse\_a\_rep}}). You can also choose to clip only the selected features of
the vector layer if there are any

\item {} 
\sphinxstyleemphasis{Overlay layer}: the \sphinxcode{\sphinxupquote{area\_of\_interest}} layer

\item {} 
\sphinxstyleemphasis{Clipped}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2.5.2_clip_vector}.PNG}
\caption{Clip vector function layer}\label{\detokenize{preparation/preparation:id7}}\end{figure}
\end{quote}
\end{quote}

\item {} 
\sphinxstylestrong{Clipping raster layer}
\begin{quote}

Available at \sphinxstyleemphasis{Raster-\textgreater{}Extraction-\textgreater{}Clip raster by mask layer}, it provides an algorithm that clips a raster layer using a vector layer as a mask.
The input parameters are:
\begin{quote}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the raster layer to be clipped (in the example \sphinxcode{\sphinxupquote{Seoul\_DTM\_rep}})

\item {} 
\sphinxstyleemphasis{Mask layer}: the \sphinxcode{\sphinxupquote{area\_of\_interest}} layer

\item {} 
\sphinxstyleemphasis{Clipped (extent)}: the path and the name of the output raster layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2.5.3_clip_raster}.PNG}
\caption{Clip raster by mask layer function window}\label{\detokenize{preparation/preparation:id8}}\end{figure}
\end{quote}
\end{quote}

\end{enumerate}

In order to continue with the tutorial please clip all the vector and the DTM raster layer following the examples above.

\begin{sphinxadmonition}{note}{Note:}
In this exercise we will refer to the new clipped layers as \sphinxcode{\sphinxupquote{\sphinxstyleemphasis{originalname}\_clip}}. You can create your
new layers with the same name in order to be consistent with the naming
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
After clipping all the layers you can delete the starting layers from the Layers panel.
\end{sphinxadmonition}

The final configuration of the application and data should be like the one in the next image.

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{2.5.3_final_map}.PNG}


\paragraph{Vector operations}
\label{\detokenize{vector/vector:vector-operations}}\label{\detokenize{vector/vector::doc}}

\subparagraph{Buffer operations}
\label{\detokenize{vector/buffer:buffer-operations}}\label{\detokenize{vector/buffer::doc}}
We will now focus on the analysis and manipulation of line shapefiles. To do so, let’s consider only the \sphinxcode{\sphinxupquote{roads\_clip}} shapefile.
You can turn-off all the other layers in the Layers panel to have a more compact visualization of the data.

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{3_roads_network}.PNG}

A very common operation with line shapefiles is the buffer which allows to create an area within a specified distance from features.
Note that in QGIS a buffer can be done also around point or polygon shapefiles. To create a buffer, click on
\sphinxstyleemphasis{Vector-\textgreater{}Geoprocessing Tools-\textgreater{}Buffer} and specify the input parameters as follows:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the \sphinxcode{\sphinxupquote{roads\_clip}} layer

\item {} 
\sphinxstyleemphasis{Distance}: the desired distance (in our case 10m). Note that you can also specify the unit of measure

\item {} 
\sphinxstyleemphasis{Segments}: the number of line segments to be used to approximate a quarter circle when creating rounded offsets (in our case 5)

\item {} 
\sphinxstyleemphasis{Buffered}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.1_buffer}.PNG}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

This will create a buffer area around our roads layer; if you zoom on your map, the result should look the following.

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{3.1_buffer_result}.PNG}

You can also create multiple buffers around the same features, within a specified distance.

To select the above function, we introduce here a very powerful instrument in QGIS: the Processing Toolbox. To add it to your window,
go to \sphinxstyleemphasis{View-\textgreater{}Panels} and tick “Processing Toolbox panel”. It should appear on the right side of your screen; this panel contains all
the functions of QGIS, and in particular, the search bar is very useful to find the function you need.

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{3.1_processing_toolbox}.png}

In this case, you can search for “Multi-ring” and select the function \sphinxstyleemphasis{Multi-ring buffer (constant distance)}. The input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the \sphinxcode{\sphinxupquote{roads\_clip}} layer

\item {} 
\sphinxstyleemphasis{Number of rings}: in our case 3

\item {} 
\sphinxstyleemphasis{Distance between rings}: in our case 10m

\item {} 
\sphinxstyleemphasis{Multi-ring buffer (constant distance)}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.1_multi_ring_buffer}.PNG}

This will create a three buffer areas around our roads layer; if you zoom on your map, and if properly styled, the result should look like this:

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{3.1_multi_ring_buffer_result}.PNG}


\subparagraph{Merge vector layers}
\label{\detokenize{vector/merge:merge-vector-layers}}\label{\detokenize{vector/merge::doc}}
Let’s now consider the polygons layers: in particular we will need the \sphinxcode{\sphinxupquote{buildings}}, \sphinxcode{\sphinxupquote{landuse\_a}}, \sphinxcode{\sphinxupquote{pois\_a}}, \sphinxcode{\sphinxupquote{pofw\_a}}
and \sphinxcode{\sphinxupquote{water\_a}} layers, so you can hide all the others in the map.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{3.2_only_polygons}.PNG}
\end{figure}

The Merge vector layers function, available at \sphinxstyleemphasis{Processing Toolbox-\textgreater{}Vector General-\textgreater{}Merge vector layers}, provides an algorithm that
combines multiple vector layers of the same geometry type into a single one. If the attributes tables are different, the attribute
table of the resulting layer will contain the attributes from all input layers. New attributes will be added for the original layer
name and source. We will use it to combine the \sphinxcode{\sphinxupquote{landuse\_a}} and the \sphinxcode{\sphinxupquote{water\_a}} in order to get a general layer describing both
land and water features. To do so, the input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layers}: click on the icon on the left and select \sphinxcode{\sphinxupquote{landuse\_a}} and \sphinxcode{\sphinxupquote{water\_a}}

\item {} 
\sphinxstyleemphasis{Destination CRS}: select the Project CRS, that should be \sphinxguilabel{EPSG:32652 - WGS84 / UTM zone 52N}

\item {} 
\sphinxstyleemphasis{Merged}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.2_merge}.PNG}
\caption{Merge function window}\label{\detokenize{vector/merge:id1}}\end{figure}

As you can see this operation creates a new vector that contains features from both the landuse and water bodies layers:

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{3.2_merge_result}.PNG}


\subparagraph{Overlay operations}
\label{\detokenize{vector/overlay:overlay-operations}}\label{\detokenize{vector/overlay::doc}}

\subparagraph{Union}
\label{\detokenize{vector/overlay:union}}\begin{quote}

The Union function, available at \sphinxstyleemphasis{Vector-\textgreater{}Geoprocessing-\textgreater{}Union}, provides an algorithm that checks overlapping features within
an input layer and creates separate features for overlapping and non-overlapping parts. The area of overlap will create as many
identical overlapping features as there are features that participate to that overlap.

In this exercise, we perform an Union between the \sphinxcode{\sphinxupquote{pois\_a}} layer (points of interest) and the \sphinxcode{\sphinxupquote{buildings\_a}} layer,
so that we will get a layer representing both residential buildings and interest/public buildings. The input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: \sphinxcode{\sphinxupquote{pois\_a}} layer

\item {} 
\sphinxstyleemphasis{Overlay layer}: \sphinxcode{\sphinxupquote{buildings\_a}} layer

\item {} 
\sphinxstyleemphasis{Union}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.3.1_union}.PNG}
\caption{Union function window}\label{\detokenize{vector/overlay:id1}}\end{figure}

The result, if zoomed, should look like the following:

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{3.3.1_union_result}.PNG}
\end{quote}


\subparagraph{Intersection}
\label{\detokenize{vector/overlay:intersection}}\begin{quote}

We can now look at the Intersection function. It is available at \sphinxstyleemphasis{Vector-\textgreater{}Geoprocessing Tools-\textgreater{}Intersection}, and it provides a function
that extracts the overlapping portions of the features of two layers and assigns these portions the attribute of both layers.
We use it to see which buildings are also religious buildings. The input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: \sphinxcode{\sphinxupquote{buildings\_a}} layer

\item {} 
\sphinxstyleemphasis{Overlay layer}: \sphinxcode{\sphinxupquote{pofw\_a}} layer

\item {} 
\sphinxstyleemphasis{Intersection}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.3.2_intersection}.PNG}
\caption{Intersection function window}\label{\detokenize{vector/overlay:id2}}\end{figure}

The results should look like the following picture. As you can see, the intersection layer (yellow)
only contains the buildings that also are religious buildings:

\noindent\sphinxincludegraphics{{3.3.2_intersection_result}.PNG}
\end{quote}


\subparagraph{Dissolve}
\label{\detokenize{vector/overlay:dissolve}}\begin{quote}

We will now use the Dissolve function applied to the \sphinxcode{\sphinxupquote{landuse\_a}} layer. The Dissolve function, available at
\sphinxstyleemphasis{Vector-\textgreater{}Geoprocessing tools-\textgreater{}Dissolve}, provides an algorithm that takes a vector layer and combines their features
into new features. One or more attributes can be specified to dissolve features belonging to the same class (having
the same value of a specific attribute), alternatively, all features can be dissolved into a single one.
We will create a new landuse layer that has as many features as the different types of land use. The input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the \sphinxcode{\sphinxupquote{landuse\_a}} layer

\item {} 
\sphinxstyleemphasis{Dissolve fields}: click the icon on the left and select the “fclass” attribute

\item {} 
\sphinxstyleemphasis{Dissolved}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.3.3_dissolve}.PNG}
\caption{Dissolve function window}\label{\detokenize{vector/overlay:id3}}\end{figure}

If you now check the attribute table of the newly created layer it should have only a few features, each corresponding to one type of land use.

\noindent\sphinxincludegraphics{{3.3.3_dissolved_result}.PNG}
\end{quote}


\subparagraph{Difference}
\label{\detokenize{vector/overlay:difference}}\begin{quote}

We can now use the newly created \sphinxcode{\sphinxupquote{landuse\_dissolved}} layer to perform a Difference operation. Difference is a function available at
\sphinxstyleemphasis{Vector-\textgreater{}Geoprocessing Tools-\textgreater{}Difference}, that extracts features of an Input layer that fall outside features in the Overlay layer
(totally or partially). If a feature of the Input layer partially overlaps a feature of the Overlay layer only the portions outside
the Overlay layer features are retained. We will use it to filter out all the natural land use leaving only the industrial and urbanized ones.
To do so, first, we have to select the natural landuse features:
\begin{itemize}
\item {} 
Right-click on the \sphinxcode{\sphinxupquote{landuse\_dissolved}} layer on the Layers panel

\item {} 
Open its Attribute table

\item {} 
Manually select the features having these classes by holding Ctrl and clicking on the row number on the left
\begin{itemize}
\item {} 
heath

\item {} 
forest

\item {} 
scrub

\item {} 
orchard

\item {} 
natural\_reserve

\item {} 
farm

\item {} 
meadow

\item {} 
vineyard

\item {} 
grass

\end{itemize}

\end{itemize}

\noindent\sphinxincludegraphics{{3.3.4_difference_selection}.PNG}

Now that we have selected those features, we can go on with the Difference operation. The input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the \sphinxcode{\sphinxupquote{landuse\_a}} layer

\item {} 
\sphinxstyleemphasis{Overlay layer}: the \sphinxcode{\sphinxupquote{landuse\_dissolved}} layer, but be sure to check the “Selected features only” checkbox

\item {} 
\sphinxstyleemphasis{Difference}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.3.4_difference}.PNG}
\caption{Difference function window}\label{\detokenize{vector/overlay:id4}}\end{figure}

The result will be a landuse layer that only retains the features with industrial and urbanized landuse types.
\end{quote}


\subparagraph{Symmetrical difference}
\label{\detokenize{vector/overlay:symmetrical-difference}}\begin{quote}

The Symmetrical difference, available at \sphinxstyleemphasis{Vector-\textgreater{}Geoprocessing Tools-\textgreater{}Symmetrical Difference}, provides a function that extracts
the portions of features from both the Input and Overlay layers that do not overlap. The attribute table of the Symmetrical Difference
layer contains original attributes from both the Input and Overlay layers.

If you look at the \sphinxcode{\sphinxupquote{landuse\_a}} layer, you will see it has some portions that overlap with water features:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{3.3.5_landuse_water_1}.PNG}
\caption{Water bodies (gray) overlapping landuse features (green)}\label{\detokenize{vector/overlay:id5}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{3.3.5_landuse_water_2}.PNG}
\caption{Only landuse features (green)}\label{\detokenize{vector/overlay:id6}}\end{figure}

We will use the Symmetrical difference to obtain a landuse layer with no feature that has parts in water bodies.
To do so, the input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: \sphinxcode{\sphinxupquote{merge\_vector}} layer

\item {} 
\sphinxstyleemphasis{Overlay layer}: \sphinxcode{\sphinxupquote{water\_a}} layer

\item {} 
\sphinxstyleemphasis{Symmetrical Difference}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.3.5_symmetrical_difference}.PNG}
\caption{Symmetrical difference function window}\label{\detokenize{vector/overlay:id7}}\end{figure}

Once the execution is done, the results should look like this:

\noindent\sphinxincludegraphics{{3.3.5_symmetrical_difference_result}.PNG}
\end{quote}


\subparagraph{Spatial join}
\label{\detokenize{vector/overlay:spatial-join}}\begin{quote}

As you see with the intersection function we can find the buildings that are also religious places. We will now use the
Join Attributes by Location function (generally known as Spatial Join) available at \sphinxstyleemphasis{Vector-\textgreater{}Data Management Tools-\textgreater{}Join Attributes by Location},
to extend the previous analysis. The Join attributes by location is a function that takes an input vector layer and creates a new vector
layer that is an extended version of the input one, with additional attributes in its attribute table. The additional attributes and their
values are taken from a second vector layer applying spatial criteria to select the values from the second layer that are added to each
feature from the first layer in the resulting one. In this way we could add the attribute that specifies the religion practised in a
particular building; the input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the buildings layer

\item {} 
\sphinxstyleemphasis{Join layer}: the pofw\_a layer

\item {} 
\sphinxstyleemphasis{Geometric predicate}: within

\item {} 
\sphinxstyleemphasis{Fields to add}: click on the icon on the left and select the “fclass” attribute

\item {} 
\sphinxstyleemphasis{Join type}: take attributes of the first located feature only (one-to-one)

\item {} 
Tick the “Discard record which cannot be joined” option

\item {} 
\sphinxstyleemphasis{Joined layer}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.3.6_spatial_join}.PNG}
\caption{Join Attributes by Location function window}\label{\detokenize{vector/overlay:id8}}\end{figure}

If you now look at the attribute table of the newly created layer, you will see a new attribute (fclass\_2)
that represents the religion practiced in that building.

\noindent\sphinxincludegraphics{{3.3.6_spatial_join_result}.PNG}

\begin{sphinxadmonition}{note}{Note:}
The Join Attributes by Location function, specifying the “intersects” predicate, also translates the “Identity” function of ArcGIS
\end{sphinxadmonition}
\end{quote}


\subparagraph{Proximity analysis}
\label{\detokenize{vector/proximity:proximity-analysis}}\label{\detokenize{vector/proximity::doc}}
We will now focus on operations involving point layers. Please note that QGIS, when clipping a Point layer, also converts
its geometry type to MultiPoint. This geometry type is not suitable for some of the functions we will use in the next step
and therefore we see first how to convert the geometry type back to Point.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.4_MultiPoint}.PNG}
\caption{In the information of the \sphinxcode{\sphinxupquote{places}} layer we can see that its geometry is MultiPoint}\label{\detokenize{vector/proximity:id1}}\end{figure}


\subparagraph{Convert geometry type}
\label{\detokenize{vector/proximity:convert-geometry-type}}\begin{quote}

Available at \sphinxstyleemphasis{Processing Toolbox-\textgreater{}Vector geometry-\textgreater{}Convert geometry type}, it provides an algorithm that allows to convert the
MultiPoint features to single Point features. To do so, the input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the point layer whose geometry we want to convert. In this example we use the \sphinxcode{\sphinxupquote{places}} layer

\item {} 
\sphinxstyleemphasis{New geometry type}: select Centroids

\item {} 
\sphinxstyleemphasis{Converted}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.4.1_convert_geometry}.PNG}
\caption{Convert geometry function window}\label{\detokenize{vector/proximity:id2}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.4.1_Point}.PNG}
\caption{Now the \sphinxcode{\sphinxupquote{places}} layer’s geometry is MultiPoint}\label{\detokenize{vector/proximity:id3}}\end{figure}

In order to continue with the following functions, please convert the geometry type also for the \sphinxcode{\sphinxupquote{natural}} point layer.

\begin{sphinxadmonition}{note}{Note:}
After you are done with the conversion, you can remove the previous point layers and include in the project only the new ones.
\end{sphinxadmonition}
\end{quote}


\subparagraph{Average Nearest Neighbor}
\label{\detokenize{vector/proximity:average-nearest-neighbor}}\begin{quote}

Available at \sphinxstyleemphasis{Processing Toolbox-\textgreater{}Vector Analysis-\textgreater{}Nearest Neighbour Analysis}, it provides a function that performs nearest neighbor
analysis for a point layer. The output is generated as an HTML file with the computed statistics. We perform the Nearest Neighbor Analysis
with the \sphinxcode{\sphinxupquote{natural}} point layer; the input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layer}: the \sphinxcode{\sphinxupquote{natural}} layer

\item {} 
\sphinxstyleemphasis{Nearest Neighbor}: the path and the name of the output HTML file. Note that if left empty a temporary file will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.4.2_nearest_neighbor}.PNG}
\caption{Nearest Neighbor Analysis function window}\label{\detokenize{vector/proximity:id4}}\end{figure}

Once the operation is done, you can open the HTML file containing the results and you will see information about the Observed mean distance,
Expected mean distance, Nearest neighbour index, Number of points, and Z-Score.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.4.2_nearest_neighbor_result}.PNG}
\caption{The html result when opened in the browser}\label{\detokenize{vector/proximity:id5}}\end{figure}
\end{quote}

We now see how to calculate the nearest feature to a given point or set of points in QGIS. We distinguish between distances from point to point,
and from point to a line or polygon layer.


\subparagraph{Distance from point to point}
\label{\detokenize{vector/proximity:distance-from-point-to-point}}\begin{quote}

Available at \sphinxstyleemphasis{Processing toolbox-\textgreater{}Vector analysis-\textgreater{}Distance to nearest hub (points)}, it provides an algorithm that computes the distance between
point features taken as the origin and their closest point destination. In this case, we will calculate the distance from the \sphinxcode{\sphinxupquote{places}} layer to
the \sphinxcode{\sphinxupquote{natural}} layer. The input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Source points layer}: the \sphinxcode{\sphinxupquote{places}} shapefile

\item {} 
\sphinxstyleemphasis{Destination hubs layer}: the \sphinxcode{\sphinxupquote{natural}} shapefile

\item {} 
\sphinxstyleemphasis{Hub layer name attribute}: osm\_id

\item {} 
\sphinxstyleemphasis{Measurement units}: meters

\item {} 
\sphinxstyleemphasis{Hub distance}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.4.3_distance_points}.PNG}
\caption{Distance from point to point function window}\label{\detokenize{vector/proximity:id6}}\end{figure}

The result is a copy of the places layer, but each point feature has two additional attributes: the id of the nearest natural point feature,
and the distance from it, as you can see from its attribute table:

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{3.4.3_distance_points_result}.PNG}
\end{quote}


\subparagraph{Distance from point to layer}
\label{\detokenize{vector/proximity:distance-from-point-to-layer}}\begin{quote}

Available at \sphinxstyleemphasis{Processing Toolbox-\textgreater{}Vector analysis-\textgreater{}Distance to nearest hub (line to hub)}, it provides an algorithm that computes the distance between
point features taken as origin and their closest destination line or polygon feature.

\begin{sphinxadmonition}{note}{Note:}
Distance calculations are based on the centroid of the line or polygon features.
\end{sphinxadmonition}

In this case, we calculate the closest forest to each place. To do so, we select all the forests from the \sphinxcode{\sphinxupquote{landuse\_a}} layer:
\begin{itemize}
\item {} 
Right-click on the \sphinxcode{\sphinxupquote{landuse\_a}} layer in the Layers panel and click on Open attribute table

\item {} 
Click on the Select features using an expression button

\item {} 
In the window, write the following expression: \sphinxcode{\sphinxupquote{"fclass" is 'forest'}}, and then click “Select features”

\end{itemize}

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.4.4_select_expression}.PNG}

Once we have selected all the forests from the landuse layer, we can run the Distance to nearest hub (line to hub) function. The input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Source points layer}: the \sphinxcode{\sphinxupquote{places}} layer

\item {} 
\sphinxstyleemphasis{Destination hubs layer}: the \sphinxcode{\sphinxupquote{landuse\_a}} layer, considering only selected features

\item {} 
\sphinxstyleemphasis{Hub layer name attribute}: osm\_id

\item {} 
\sphinxstyleemphasis{Measurement units}: meters

\item {} 
\sphinxstyleemphasis{Hub distance}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.4.4_distance_polygons}.PNG}
\caption{Distance from point to layer function window}\label{\detokenize{vector/proximity:id7}}\end{figure}

The result is a line layer representing all the distances from each places point feature to the nearest forest feature.

\noindent\sphinxincludegraphics{{3.4.4_distance_polygons_result}.PNG}
\end{quote}


\subparagraph{Network analysis}
\label{\detokenize{vector/network:network-analysis}}\label{\detokenize{vector/network::doc}}

\subparagraph{Shortest path}
\label{\detokenize{vector/network:shortest-path}}\begin{quote}

In order to find the shortest or fastest path in QGIS, we can use the Shortest path function. Having a layer representing a network, we can
calculate the shortest path between two chosen points on the map (point to point), from a point layer to a chosen end point (layer to point)
or from a chosen start point to a point layer (point to layer).

We illustrate here only the point to point option for the sake of computation, but the others are easily deduced from the following example.
The function is available at \sphinxstyleemphasis{Processing Toolbox-\textgreater{}Network analysis-\textgreater{}Shortest path (point to point)}, and the input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Vector network layer}: the \sphinxcode{\sphinxupquote{roads}} layer

\item {} 
\sphinxstyleemphasis{Path type to calculate}: shortest (you can also calculate the fastest path given a network layer with maximum velocity information)

\item {} 
\sphinxstyleemphasis{Start point}: click on the icon on the right, then choose a starting point from the map

\item {} 
\sphinxstyleemphasis{End point}: click on the icon on the right, then choose an ending point from the map

\item {} 
\sphinxstyleemphasis{Shortest path}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.5.1_shortest_path}.PNG}
\caption{Shortest path (point to point) function window}\label{\detokenize{vector/network:id1}}\end{figure}

As you can see this algorithm creates a new line layer that represents the shortest path in the provided network to go from the starting
point to the end point:

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{3.5.1_shortest_path_result}.PNG}
\end{quote}


\subparagraph{Generate service area}
\label{\detokenize{vector/network:generate-service-area}}\begin{quote}

In QGIS, we can also generate a service area using the Service Area function. To perform such, you can search for Service area in the Processing
toolbox searchbar and select \sphinxstyleemphasis{Service area (from point)}. This function allows creating a vector with all the edges or parts of edges of a network
layer that can be reached within a distance or a time, starting from a point chosen on the map. The same can be done starting from a point layer
using \sphinxstyleemphasis{Service area (from layer)}. We will use the last one to calculate the service area for all the places points with a maximum travel distance
of 100 meters. The input parameters are:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Vector network layer}: the \sphinxcode{\sphinxupquote{roads}} network

\item {} 
\sphinxstyleemphasis{Vector layer with start points}: the :file{}`places{}` layer

\item {} 
\sphinxstyleemphasis{Path type to calculate}: shortest (you can also calculate the fastest path given a network layer with maximum velocity information)

\item {} 
\sphinxstyleemphasis{Travel cost}: 100 (so that the maximum travel distance is 100m)

\item {} 
\sphinxstyleemphasis{Service area}: the path and the name of the output vector layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.5.2_service_area}.PNG}
\caption{Generate service area function window}\label{\detokenize{vector/network:id2}}\end{figure}

The result will highlight the service area for each point of the places layer:

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{3.5.2_service_area_result}.PNG}
\end{quote}


\subparagraph{Kernel density}
\label{\detokenize{vector/kernel:kernel-density}}\label{\detokenize{vector/kernel::doc}}
A useful tool to visualize the density of a point layer it is the Heatmap. In QGIS, we can directly use a styling option of the layer.
\begin{quote}
\begin{itemize}
\item {} 
Right-click the \sphinxcode{\sphinxupquote{places}} layer on the Layers panel

\item {} 
Select Properties

\item {} 
In the menu on the left, select Symbology

\end{itemize}

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.6_simbology}.PNG}
\begin{itemize}
\item {} 
In the dropdown menu on top, select Heatmap

\end{itemize}

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.6_simbology_heatmap}.PNG}
\begin{itemize}
\item {} 
Now you only have to choose the parameters:
\begin{itemize}
\item {} 
Color ramp: reds

\item {} 
Radius and radius unit of measure: 10 millimetres

\item {} 
Maximum value (leave Automatic)

\end{itemize}

\end{itemize}

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{3.6_heatmap_parameters}.PNG}
\begin{itemize}
\item {} 
Then click OK button on the bottom

\end{itemize}

The result is the visualization of the places layer as a heatmap, as you can see comparing
the heatmap with a copy of the \sphinxcode{\sphinxupquote{places}} layer with the point symbols:

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{3.6_heatmap_result}.PNG}
\end{quote}


\subparagraph{Inverse Distance Weighting}
\label{\detokenize{vector/idw:inverse-distance-weighting}}\label{\detokenize{vector/idw::doc}}
We can also interpolate a point layer to create a raster layer out of it. One method to do so is the Inverse Distance Weighting (IDW)
interpolation technique. To perform IDW interpolation in QGIS we have to rely on the external functionalities provided by GRASS GIS that
are directly accessible form the Processing Toolbox of QGIS.
The function is called v.surf.idw, and it’s available at \sphinxstyleemphasis{Processing Toolbox-\textgreater{}GRASS-\textgreater{}Vector(.v*)}. We can compute a raster by interpolating
the places layer, using as the interpolation variable the population:
\begin{itemize}
\item {} 
Input vector layer: the places layer

\item {} 
Attribute table column with values to interpolate: select population

\item {} 
Interpolated IDW: the path and the name of the output raster layer. Note that if left empty a temporary layer will be created

\end{itemize}


\paragraph{Raster operations}
\label{\detokenize{raster/raster:raster-operations}}\label{\detokenize{raster/raster::doc}}

\subparagraph{Merge raster}
\label{\detokenize{raster/merge:merge-raster}}\label{\detokenize{raster/merge::doc}}
We see now how to  Merge multiple raster layers. We do it by combining the Landsat8 imagery bands with the aim of creating a multi-band raster.
To do so, we have to first add the raster bands into our QGIS project. From the the Browser panel, navigate to the raster data folder and into
the folder containing the Landsat data (\sphinxcode{\sphinxupquote{Landsat8\_20160519\_20170324\_01\_T1}}). Then add the raster ending with B2, B3 and B4
(in Landsat images they represent respectively the blue, green and red channels). These images are already in our prokect CRS (\sphinxguilabel{EPSG:32652 - WGS 84 / UTM zone 52N})
so once you added the raster data, go directly to \sphinxstyleemphasis{Raster-\textgreater{}Miscellaneous-\textgreater{}Merge}, and put this input parameters:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Input layers}: click on the left symbol and select the Landsat\_B2, Landsat\_B3 and Landsat\_B4 images

\item {} 
Tick the “Place each input file into a separate band” checkbox: when not activated, this option is used to merge raster layers covering
different area and not overlapping between each other. In our case we want to merge images that totally overlap between one another

\item {} 
\sphinxstyleemphasis{Output data type}: change it to UInt16 to be consistent with the original rasters

\item {} 
\sphinxstyleemphasis{Merged}: the path and the name of the output raster layer. Note that if left empty a temporary layer will be created

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{4.1_merge_raster}.PNG}
\caption{The merge raster function window}\label{\detokenize{raster/merge:id1}}\end{figure}

The obtained multiband raster at first will look like this:

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{4.1_merge_raster_result}.PNG}

To obtain what is called a “true color image”, so a multiband raster whose color resembles the real ones, you have to change the band assigned to each
color. To do so, right-click on the multiband raster and select properties. Go in the Symbology section, and you will see a window like the following:

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{4.1_true_color_1}.PNG}

Then, assign to the Red band the Band 3, to the Green band the Band 2 and to the Blue band the Band 1.

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{4.1_true_color_2}.PNG}

The true color map obtained should look like this:

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{4.1_true_color_result}.PNG}

\begin{sphinxadmonition}{note}{Note:}
This is not an accurate true color map because there was no atmospheric correction applied to the Landsat images,
so you’ll find that its colors are brighter than the real ones.
\end{sphinxadmonition}


\subsection{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}